function [A, B, C, par_consts, breast, mask_pec] = skin_air(img, pectoral, flip, resize_param)

%% Perform Otsu's method to get background part
% Get binary background image:
breast = sa_otsu(img, flip, resize_param);
theta = pectoral(1);
rho = pectoral(2);

if isnan(theta) && isnan(rho)
    %% No pectoral line found. Set all values depending on pectoral line to
    % NaN.
    A = NaN; B = NaN; C = NaN;
    par_consts = [NaN NaN];
    mask_pec = NaN;
else
    %% Pectoral linje found. Perform steps to find
    % A, B, C, parabolae constants and mask generated by parabolae
    % constants along with the pectoral line
    
    %% Get edge points using canny edge detection
    I_edges = edge(breast, 'canny');
    resize_param{1}(:,1) = resize_param{1}(:,1) + 1;
    % Cap edges in top and "backside" of breast
    % Subtract tree pixels from right-capping in order to allow
    I_edges = im_capframe(I_edges, flip, resize_param{1});
    if flip
        I_edges = flipdim(I_edges,2);
    end

    %% Registering of skin-air points and rotation
    % Set up rotation matrices
    R = rotational_matrix(-theta);       % Rotate to pec-axis
    R_org = rotational_matrix(theta);  % Rotate back to (x,y)

    % Find (x,y)-coordinates of edge points
    [y x] = find(I_edges);
    p = [x y];

    %% Find skin-air boundary (work in pec-coordinates)
    % Rotate edge points to pec-axis
    p_pec = p * R;
    % Translate points so that the 0-axis gets to be the pectoral line
    p_pec(:,1) = p_pec(:,1) - rho;

    % Calculate center of mass (com) from foreground image (~I_bg),
    % rotate and find point on parabola
    [com(1), com(2)] = center_of_mass(img .* ~breast);
    start_potentials = find(ceil(p(:,2)) == round(com(2)) | round(com(2)) == floor(p(:,2)));

    % In case of multiple points choose the one with lowest original x-value
    [~, start_ind] = min(p(start_potentials,1));

    % Set start point for line growing
    start = [p_pec(start_potentials(start_ind),1)...
             p_pec(start_potentials(start_ind),2)];

    % Get linepoints on skin-air boundary
    figure, imshow(I_edges);
    [skin_air, start_ind] = sa_grow_line(p_pec, start);
    
    % Filter away irrelevant points (noise at the edges that wasn't able to be
    % removed duing identification of skin-air boundary
    skin_air = sa_filter_line(skin_air, start_ind);

    % Identify A_rot on skin-air line
    [A_rot, A_ind] = sa_identify_A(skin_air);

    %% Estimate pectoral lines
    % work in A_rot-coordinates (A_rot = orego and skin-air boundary grows
    % upwards)

    % Transform points so that A is orego and pectoral line grows upwards
    sa_A(:,2) = A_rot(1) - skin_air(:,1);
    sa_A(:,1) = skin_air(:,2) - A_rot(2);

    % Perform least squares fitting
    % bottom breastparabolae (work on right-hand side)
    line_bottom = sa_A(A_ind+1:end,:);
    bottom_a = sum(line_bottom(:,2).*(line_bottom(:,1).^2)) /...
               sum(line_bottom(:,1).^4);

    % upper breastparabolae (work on left-hand side)
    line_upper = sa_A(1:A_ind,:);
    upper_a = sum(line_upper(:,2).*(line_upper(:,1).^2)) /...
              sum(line_upper(:,1).^4);

    % Calculate B as y = A_rot(1) = a_top x^2
    B_A(1) = -sqrt(A_rot(1) / upper_a);
    B_A(2) = A_rot(1);

    % Calculate C
    C_A(1) = sqrt(A_rot(1) / bottom_a);
    C_A(2) = A_rot(1);

    % Evaluate points to show graph of polynomials
    bottom_pol_x = 0:C_A(1);
    upper_pol_x = 0:-1:B_A(1);
    bottom_pol_y = polyval([bottom_a, 0, 0],bottom_pol_x);
    upper_pol_y = polyval([upper_a, 0, 0], upper_pol_x);
    
    % Transform points from A-coordinates to pec-coordinates
    % Translate and invert points
    % Transform polynomial points
    bottom_pec(:,1) = A_rot(1) - bottom_pol_y;
    upper_pec(:,1) = A_rot(1) - upper_pol_y;
    bottom_pec(:,2) = bottom_pol_x + A_rot(2);
    upper_pec(:,2) = upper_pol_x + A_rot(2);
    
    % Transform B:
    B_pec(1) = A_rot(1) - B_A(2);
    B_pec(2) = A_rot(2) + B_A(1);
    
    % Transform C:
    C_pec(1) = A_rot(1) - C_A(2);
    C_pec(2) = A_rot(2) + C_A(1);

    % Define parabolae constants (in A-coords)
    par_consts = [upper_a, bottom_a];

    %% Transform all pec-axis coordinates to (x,y)-coordinates
    % Transform A:
    A_rot(1) = A_rot(1) + rho;
    A = A_rot * R_org;

    % Transform B:
    B_pec(1) = B_pec(1) + rho;
    B = B_pec * R_org;

    % Transform C:
    C_pec(1) = C_pec(1) + rho;
    C = C_pec * R_org;

    % Transform parabolaes
    bottom_pec(:,1) = bottom_pec(:,1) + rho;
    upper_pec(:,1) = upper_pec(:,1) + rho;
    bottom_pec = bottom_pec * R_org;
    upper_pec = upper_pec * R_org;

    %% Flip coordinates if image is flipped
    [a b] = hough2xy(rho, theta);
    pec_x = C(1):B(1);
    pec_y = polyval([a b],pec_x);
    
    %{
    figure, imshow((flipdim(img,2)), [min(img(:)) max(img(:))]);
    hold on, axis equal;
    plot(pec_x, pec_y, 'linewidth',2,'color','red');
    plot(upper_pec(:,1), upper_pec(:,2),'linewidth',2,'color','blue');
    plot(bottom_pec(:,1), bottom_pec(:,2),'linewidth',2,'color','red');
    plot(A(1),A(2), 'Dg');
    plot(B(1), B(2), 'Xb');
    plot(C(1), C(2), 'Xr');
    %}
    
    if flip
        bottom_pec(:,1) = size(img,2) - bottom_pec(:,1);
        upper_pec(:,1) = size(img,2) - upper_pec(:,1);
        A(1) = size(img,2) - A(1);
        B(1) = size(img,2) - B(1);
        C(1) = size(img,2) - C(1);
        pec_x = size(img,2) - pec_x;
    end
    
    %% Show figures:
    %{
    figure, imshow((img.* breast), [min(img(:)) max(img(:))]);
    hold on, axis equal;
    plot(pec_x, pec_y, 'linewidth',2,'color','red');
    plot(upper_pec(:,1), upper_pec(:,2),'linewidth',2,'color','blue');
    plot(bottom_pec(:,1), bottom_pec(:,2),'linewidth',2,'color','red');
    plot(A(1),A(2), 'Dg');
    plot([B(1), C(1)],[B(2),C(2)],'Xb');
    %}
    
end

mask_pec = [];